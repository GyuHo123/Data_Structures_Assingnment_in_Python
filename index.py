import copy
import unittest
import doctest

class SampleTest(unittest.TestCase):
    def test_nums1(self):
        a = [[0, 2, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
        tree = [[], [[[0, 2, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 2, 0], [0, 0, 0, 0], [2, 1, 3, 0]], [[4, 2, 1, 3], [1, 3, 4, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 2, 4], [0, 0, 0, 0], [2, 1, 3, 0]], [[4, 2, 1, 3], [1, 3, 4, 2], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 2, 4], [3, 0, 0, 0], [2, 1, 3, 0]], [[4, 2, 1, 3], [1, 3, 4, 2], [3, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 2, 4], [3, 4, 0, 0], [2, 1, 3, 0]], [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 0, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 0], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 1], [2, 1, 3, 0]]], [[[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 1], [2, 1, 3, 4]]]]
        answer = [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 1], [2, 1, 3, 4]]
        print(solvesudoku2by2(a))
        self.assertListEqual(sudoku,answer)
        self.assertListEqual(tree, tree_depth)
    def test_nums2(self):
        b = [[0, 3, 1, 2], [3, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
        re = "Impossible\n"
        self.assertEqual(re, solvesudoku2by2(b))
    def test_nums3(self):
        c = [[0, 3, 1, 2], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
        tree = [[], [[[0, 3, 1, 2], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 0], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 3], [0, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 3], [3, 0, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 0, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 0], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 1], [2, 1, 3, 0]]], [[[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 1], [2, 1, 3, 4]]]]
        answer = [[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 1], [2, 1, 3, 4]]
        print(solvesudoku2by2(c))

        self.assertListEqual(sudoku,answer)
        self.assertListEqual(tree, tree_depth)
"""
tree_depth, depth 초기화 필요.
"""

sudoku = []
tree_depth = list()
depth = 0
def solvesudoku2by2(a):
    """리스트형 변수를 인자로 받는다. 받은 리스트는 스도쿠 보드판이 된다.
    보드판 기준으로 스도쿠를 푼다.
    DFS와 백트래킹을 이용해 스도쿠를 해결했으며, 결과를 print한다.
    정상 동작시 저장해두었던 스도쿠 보드판과 tree_depth 리스트를 출력하며,
    비정상 동작시 "Impossible\n"을 출력한다.

    Args:
        a (list): 풀이 할 2x2 스도쿠 배열
    Returns:
        _type_: if(dfs(0,0)):
                    list()
                else:
                    String
-----------------------------------------------------------------------------------------------------------------------------------
    >>> print(solvesudoku2by2(a))
    [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 1], [2, 1, 3, 4]]
    <BLANKLINE>
    tree_depth, a
    <BLANKLINE>
    1, [[0, 2, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    2, [[4, 2, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    3, [[4, 2, 1, 3], [1, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    4, [[4, 2, 1, 3], [1, 3, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    5, [[4, 2, 1, 3], [1, 3, 2, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    5, [[4, 2, 1, 3], [1, 3, 4, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    6, [[4, 2, 1, 3], [1, 3, 2, 4], [0, 0, 0, 0], [2, 1, 3, 0]]
    6, [[4, 2, 1, 3], [1, 3, 4, 2], [0, 0, 0, 0], [2, 1, 3, 0]]
    7, [[4, 2, 1, 3], [1, 3, 2, 4], [3, 0, 0, 0], [2, 1, 3, 0]]
    7, [[4, 2, 1, 3], [1, 3, 4, 2], [3, 0, 0, 0], [2, 1, 3, 0]]
    8, [[4, 2, 1, 3], [1, 3, 2, 4], [3, 4, 0, 0], [2, 1, 3, 0]]
    8, [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 0, 0], [2, 1, 3, 0]]
    9, [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 0], [2, 1, 3, 0]]
    10, [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 1], [2, 1, 3, 0]]
    11, [[4, 2, 1, 3], [1, 3, 4, 2], [3, 4, 2, 1], [2, 1, 3, 4]]
    >>> print(solvesudoku2by2(b))
    Impossible
    <BLANKLINE>
    >>> print(solvesudoku2by2(c))
    [[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 1], [2, 1, 3, 4]]
    <BLANKLINE>
    tree_depth, a
    <BLANKLINE>
    1, [[0, 3, 1, 2], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    2, [[4, 3, 1, 2], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    3, [[4, 3, 1, 2], [1, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    4, [[4, 3, 1, 2], [1, 2, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    5, [[4, 3, 1, 2], [1, 2, 4, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    6, [[4, 3, 1, 2], [1, 2, 4, 3], [0, 0, 0, 0], [2, 1, 3, 0]]
    7, [[4, 3, 1, 2], [1, 2, 4, 3], [3, 0, 0, 0], [2, 1, 3, 0]]
    8, [[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 0, 0], [2, 1, 3, 0]]
    9, [[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 0], [2, 1, 3, 0]]
    10, [[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 1], [2, 1, 3, 0]]
    11, [[4, 3, 1, 2], [1, 2, 4, 3], [3, 4, 2, 1], [2, 1, 3, 4]]
    """

    global sudoku
    global tree_depth
    global depth
    temp = copy.deepcopy(a)
    sudoku = copy.deepcopy(temp)
    depth = 0
    tree_depth = list()
    if (dfs(0, 0)):
        tree_depth[1].append(copy.deepcopy(temp))
        print(sudoku, end='\n\n')
        print("tree_depth, a\n")
        for i in range(len(tree_depth)):
            for j in tree_depth[i]:
                print(i, end=', ')
                if (i == len(tree_depth)-1):
                    return j
                print(j)

    else:
        return "Impossible\n"

def dfs(x, y):
    """
    DFS(0,0)이 1을 return하면 DFS 함수에서 저장한 sudoku 리스트와 tree_depth 리스트의 값을 print한다.
       DFS(0,0)이 1을 return하지 않는 경우 "Impossible\n"을 print한다.
    """
    global sudoku
    global tree_depth
    global depth

    available = list()
    chk = [0, 0, 0, 0, 0]

    nx = x + (y + 1) // 4
    ny = (y + 1) % 4

    if x == 4:
        return 1
    if sudoku[x][y]:
        return dfs(nx, ny)

    for i in range(0, 4):
        chk[sudoku[x][i]] += 1
        chk[sudoku[i][y]] += 1

    rx = x - (x % 2)
    ry = y - (y % 2)

    while len(tree_depth) <= depth + 2:
        tree_depth.append(list())

    for i in range(2):
        for j in range(2):
            chk[sudoku[rx + i][ry + j]] += 1

    for i in range(1, 5):
        if chk[i] == 0:
            available.append(i)

    for k in available:
        sudoku[x][y] = k;
        depth += 1
        tree_depth[depth + 1].append(copy.deepcopy(sudoku))
        if dfs(nx, ny):
            return 1
        sudoku[x][y] = 0;
        depth -= 1

if __name__ == '__main__':
    unittest.main()
    a = [[0, 2, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    b = [[0, 3, 1, 2], [3, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    c = [[0, 3, 1, 2], [0, 0, 0, 0], [0, 0, 0, 0], [2, 1, 3, 0]]
    print(solvesudoku2by2(a))
    doctest.testmain()
